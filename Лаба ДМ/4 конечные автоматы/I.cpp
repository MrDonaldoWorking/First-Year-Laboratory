/*
      РћЈРћЊРћЈРћЂРћ│РћЈРћЂРћЈРћЊРћЈРћ│РћЊРћЃРћЈРћЊРћЈРћЊРћ│РћЃРћЈРћЊРћЈРћЊ
      РћЃРћЃРћБРћЂРћЃРћБРћЂРћБРћФРћЃРћЃРћЃРћЃРћЃРћЃРћБРћФРћЃРћЃРћЌРћЏРћЃРћЃ
      РћБРћЏРћЌРћЂРћЃРћЌРћЂРћЃРћЌРћЃРћЃРћЃРћЃРћЃРћЃРћЃРћЃРћЃРћЃ  РћЃРћЃ

                     РацРаХРаХРаХРаХРаХРаХРацРаё
 РађРађРађРађРађРађРађРааРаЙРа┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐РаиРаё
 РађРађРађРађРађРађРааРа┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐Ра┐Раё
 РађРађРађРађРађРађРаИРа┐РаЏРаЅРаЅРаЅРа╗Ра┐Ра┐РаЪРаЅРаЅРаЅРаЏРа┐РаЄ
 РађРађРађРађРађРађРаИРаЄРађРађРаХРађРаИРа┐Ра┐РаЄ ­Ъћх РаИРаЄ
 РађРађРађРађРађРађРађРа╗РаХРацРацРааРа┐РаЃРаўРа┐РаёРацРацРаХРаЪ
 РађРађРађРађРађРађРађРаЙРа┐РаЎРаХРа┐Ра┐РацРацРа┐Ра┐РаХРаЈРа╗Раи
 РађРађРађРађРађРађРађРа╗РаХРаюРа░РаГРаЕРаЇРаГРаЇРаГРа▒РааРаХРаЪ
 РађРађРађРађРааРаХРадРаѕРа╗Ра┐РаХРаГРаўРаЃРаЏРаЃРаФРа┤Ра┐РаЪРаАРаЙРаЪРаѓ
 РађРађРађРађРаіРаЅРаЏРа│РадРаѕРаЅРаЏРаЏРаЏРаЏРаЏРаЏРаЅРаЂРааРа┐РаІРађРа▒Раё
 РађРађРађРаћРађРађРаёРађРаЅРа│РадРаёРа│РаХРаХРаЃРааРацРаъРаЏРаЂРааРаѓРађРаЎРаё
 РађРађРајРађРађРађРаЄРађРађРаИРађРаЈРааРаГРаЇРаѕРаЈРаЄРађРађРађРа╝РађРађРађРаЎРає
 РађРа╝РађРађРађРађРаиРаћРањРаџРаЇРаБРаИРа┐Ра┐РаИРаІРаЄРааРа┤РаџРа╣РађРађРађРађРа╗
 РађРа╗РаёРађРађРа░РаЂРађРађРађРаЌРа╣РаИРа┐Ра┐РаИРаЅРаЄРаЄРађРађРаѕРаЄРађРађРађРаИ
 РађРађРаЎРадРаёРаИРађРађРађРађРа▒Ра╣РаИРа┐Ра┐РаИРа╣РаюРађРађРађРађРаЄРађРађРа┤РаІ
 РађРађРађРаѕРаЃРа╝РаХРаёРађРађРаИРаЙРаХРањРањРаџРаЙРацРацРацРацРаЙРаЃРаХРаіРаЂ
 РађРађРађРађРађРађРаЅРаЅРаЅРаЅРаЂРађРађРађРађРађРађРађРађРађРађРаЅ
 РађРађРађРађРађРађРаћРађРаХРађРађРађРађРађРађРађРађРаИРаЄРађРађРаБ
 РађРађРађРађРађРађРаЄРаИРаЄРађРађРађРађРајРаєРађРађРаИРаДРађРађРаИ
 РађРађРађРађРађРа░РаЂРаЙРаЂРађРађРађРааРаЄРа▒РађРађРаИРа┐РађРађРађРаЄ
 РађРађРађРађРађРаИРађРа┐РађРађРађРађРаИРађРаИРађРађРађРа┐РађРађРађРаЄ
 РађРађРађРађРађРаѕРаЅРаЅРањРањРањРањРаіРађРаѕРањРањРањРаЏРаЊРаіРаЅРаЂ
 РађРађРађРађРааРаХРаХРацРа▓РаХРађРађРађРађРађРађРааРаиРаХРаХРаѓРацРаХРадРаё
 РађРађРађРађРа┐Ра┐Ра┐Ра┐РаДРаЕРаёРађРађРађРађРађРагРаГРаГРа▒Ра┐Ра┐Ра┐Ра┐РаЪ


       РќЉРќЉРќЉРќЉРќѕРќЉРќЉРќЉРќЉРќЉРќЉРќЉРќЉРќЉРќЉРќЉРќЉРќЉРќѕРќЉРќЉРќЉРќЉ
       РќЉРќЉРќЉРќѕРќЉРќЉРќЉРќЉРќЉРќЉРќЉРќЉРќЉРќЉРќёРќёРќёРќЉРќЉРќѕРќЉРќЉРќЉ
       РќЉРќЉРќЉРќѕРќЉРќЉРќёРќёРќёРќЉРќЉРќёРќЉРќЉРќѕРќѕРќѕРќЉРќЉРќѕРќЉРќЉРќЉ
       РќЉРќЉРќЉРќёРќѕРќЉРќёРќЉРќЉРќЉРќђРќђРќђРќЉРќЉРќЉРќёРќЉРќѕРќёРќЉРќЉРќЉ
       РќЉРќЉРќЉРќѕРќЉРќЉРќђРќѕРќђРќѕРќђРќѕРќђРќѕРќђРќѕРќђРќЉРќЉРќѕРќЉРќЉРќЉ
       РќЉРќЉРќЉРќёРќѕРќѕРќёРќёРќђРќђРќђРќђРќђРќђРќђРќёРќёРќѕРќѕРќёРќЉРќЉРќЉ
       РќЉРќёРќѕРќЉРќѕРќђРќђРќѕРќђРќђРќђРќѕРќђРќђРќђРќѕРќђРќђРќѕРќЉРќѕРќёРќЉ
       РќёРќђРќЉРќёРќёРќђРќёРќёРќђРќђРќђРќёРќђРќђРќђРќёРќёРќђРќёРќёРќЉРќђРќё
       РќѕРќЉРќЉРќЉРќЉРќђРќёРќЉРќѕРќёРќЉРќЉРќЉРќёРќѕРќЉРќёРќђРќЉРќЉРќЉРќЉРќѕ
       РќЉРќђРќёРќёРќЉРќѕРќЉРќЉРќѕРќёРќёРќёРќёРќёРќѕРќЉРќЉРќѕРќЉРќёРќёРќђРќЉ
       РќЉРќЉРќЉРќђРќѕРќѕРќёРќёРќѕРќѕРќѕРќѕРќѕРќѕРќѕРќёРќёРќѕРќѕРќђРќЉРќЉРќЉ
       РќЉРќЉРќЉРќѕРќѕРќѕРќѕРќѕРќѕРќѕРќѕРќђРќѕРќѕРќѕРќѕРќѕРќѕРќѕРќѕРќЉРќЉРќЉ
       РќЉРќЉРќёРќёРќѕРќђРќђРќђРќђРќѕРќЉРќЉРќЉРќѕРќђРќђРќђРќђРќѕРќёРќёРќЉРќЉ
       РќЉРќЉРќђРќёРќёРќёРќёРќёРќђРќђРќЉРќЉРќЉРќђРќђРќёРќёРќёРќёРќёРќђРќЉРќЉ
*/

#include <stdio.h>
#include <vector>
#include <unordered_set>
#include <map>
#include <queue>

using namespace std;

const int MAX_N = 50001;

int n, m, k;
vector<bool> terminal(MAX_N), reachable(MAX_N);
vector<vector<int>> graph(MAX_N, vector<int>('z' - 'a' + 1)), newGraph(MAX_N, vector<int>('z' - 'a' + 1, -1));
vector<int> classInd(MAX_N), number(MAX_N);
unordered_set<int> newTerminal;

struct edge {
    int from, to;
    char letter;

    edge(int a, int b, char c): from(a), to(b), letter(c) {}
};
vector<edge> answer;

void stroll(int v) {
    if (reachable[v] || v == 0)
        return;
    
    reachable[v] = true;
    for (char c = 'a'; c <= 'z'; ++c)
        stroll(graph[v][c - 'a']);
}

void rec(int v) {
    if (number[v] > 0)
        return;
    
    number[v] = ++n;
    for (char c = 'a'; c <= 'z'; ++c) {
        int cm = c - 'a';
        if (newGraph[v][cm] > -1) {
            rec(newGraph[v][cm]);
            answer.push_back(edge(number[v], number[newGraph[v][cm]], c));
        }
    }
}

void createGraph() {
    for (int i = 0; i < n; ++i) {
        if (classInd[0] == classInd[i] || !reachable[i])
            continue;
        for (char c = 'a'; c <= 'z'; ++c) {
            int cm = c - 'a';
            if (classInd[graph[i][cm]] != classInd[0] && reachable[graph[i][cm]])
                newGraph[classInd[i]][cm] = classInd[graph[i][cm]];
        }
    }

    int tmp = n;
    n = m = k = 0;
    rec(classInd[1]);

    for (int i = 0; i < tmp; ++i) {
        if (!terminal[i] || classInd[i] == classInd[0] || !reachable[i])
            continue;
        newTerminal.insert(number[classInd[i]]);
    }
}

int main() {
    freopen("fastminimization.in", "r", stdin);
    freopen("fastminimization.out", "w", stdout);

    scanf("%d%d%d", &n, &m, &k);
    ++n;

    while (k--) {
        int v;
        scanf("%d", &v);
        terminal[v] = true;
    }

    vector<vector<vector<int>>> invGraph(n, vector<vector<int>>('z' - 'a' + 1));
    while (m--) {
        int from, to;
        char letter;
        scanf("%d%d %c", &from, &to, &letter);

        graph[from][letter - 'a'] = to;
    }
    for (int i = 0; i < n; ++i) {
        for (char c = 'a'; c <= 'z'; ++c)
            invGraph[graph[i][c - 'a']][c - 'a'].push_back(i);
    }

    stroll(1);

    unordered_set<int> f, qMf, nil;
    for (int i = 0; i < n; ++i) {
        if (terminal[i])
            f.insert(i);
        else {
            qMf.insert(i);
            classInd[i] = 1;
        }
    }
    vector<unordered_set<int>> p;
    p.push_back(f);
    p.push_back(qMf);
    queue<pair<int, int>> que;
    for (char c = 'a'; c <= 'z'; ++c) {
        que.push({0, c - 'a'});
        que.push({1, c - 'a'});
    }
    while (!que.empty()) {
        unordered_set<int> cla = p[que.front().first];
        int letter = que.front().second;
        que.pop();

        map<int, vector<int>> involved;
        for (int q : cla) {
            for (int r : invGraph[q][letter]) {
                int i = classInd[r];
                involved[i].push_back(r);
            }
        }

        for (auto &par : involved) {
            int i = par.first;
            if (involved[i].size() < p[i].size()) {
                int ind = (int) p.size();
                p.push_back(nil);
                for (int r : involved[i]) {
                    p[i].erase(r);
                    p[ind].insert(r);
                }

                if (p[ind].size() > p[i].size())
                    swap(p[ind], p[i]);

                for (int r : p[ind])
                    classInd[r] = ind;
                for (char c = 'a'; c <= 'z'; ++c)
                    que.push({ind, c - 'a'});
            }
        }
    }

    createGraph();

    printf("%d %d %d\n", n, (int) answer.size(), (int) newTerminal.size());
    for (int v : newTerminal)
        printf("%d ", v);
    printf("\n");
    for (edge e : answer)
        printf("%d %d %c\n", e.from, e.to, e.letter);

    return 0;
}

